---
# Package installation
- name: Determine package list
  ansible.builtin.set_fact:
    dotfiles_packages:
      - git
      - curl
      - zsh
      - less
      - vim
  tags: packages

- name: Check if sudo is available
  ansible.builtin.command: command -v sudo
  register: sudo_check
  changed_when: false
  failed_when: false
  when: install_deps | bool
  tags: packages

- name: Install prerequisites via apt (Debian/Ubuntu)
  ansible.builtin.apt:
    name: "{{ dotfiles_packages }}"
    state: present
    update_cache: true
    cache_valid_time: 3600
  when:
    - install_deps | bool
    - ansible_facts['os_family'] == 'Debian'
  become: true
  register: apt_install_result
  failed_when: false
  tags: packages

- name: Install prerequisites via dnf (Fedora)
  ansible.builtin.dnf:
    name: "{{ dotfiles_packages }}"
    state: present
  when:
    - install_deps | bool
    - ansible_facts['os_family'] == 'RedHat'
  become: true
  register: dnf_install_result
  failed_when: false
  tags: packages

- name: Install prerequisites via pacman (Arch)
  community.general.pacman:
    name: "{{ dotfiles_packages }}"
    state: present
  when:
    - install_deps | bool
    - ansible_facts['os_family'] == 'Archlinux'
  become: true
  register: pacman_install_result
  failed_when: false
  tags: packages

- name: Set package install result
  ansible.builtin.set_fact:
    pkg_install_result: "{{ apt_install_result | default(dnf_install_result) | default(pacman_install_result) | default({}) }}"
  when: install_deps | bool
  tags: packages

- name: Warn if package installation failed
  ansible.builtin.debug:
    msg: "WARNING: Package installation failed or was skipped. Required tools (git, curl, zsh) may be missing."
  when:
    - install_deps | bool
    - pkg_install_result is defined
    - pkg_install_result.failed | default(false)
  tags: packages

- name: Verify critical packages are installed
  ansible.builtin.shell: "command -v {{ item }}"
  register: critical_pkg_check
  changed_when: false
  failed_when: false
  loop:
    - git
    - zsh
  tags: packages

- name: Fail if critical packages are missing
  ansible.builtin.fail:
    msg: "CRITICAL: {{ item.item }} is not installed. Please install it manually: sudo apt-get install {{ item.item }}"
  when:
    - install_deps | bool
    - item.rc != 0
  loop: "{{ critical_pkg_check.results }}"
  tags: packages

# Repository setup
- name: Ensure dotfiles directory exists
  ansible.builtin.file:
    path: "{{ dotfiles_dir }}"
    state: directory
    mode: "0755"
  tags: repo

- name: Clone or update dotfiles repo when repo is provided
  ansible.builtin.git:
    repo: "{{ dotfiles_repo }}"
    dest: "{{ dotfiles_dir }}"
    version: HEAD
    update: true
  when: dotfiles_repo | length > 0
  tags: repo

- name: Warn if repo URL not provided
  ansible.builtin.debug:
    msg: "dotfiles_repo not set; expecting existing files in {{ dotfiles_dir }}"
  when: dotfiles_repo | length == 0
  tags: repo

# Zshrc linking with backups
- name: Ensure zsh directories exist
  ansible.builtin.file:
    path: "{{ item }}"
    state: directory
    mode: "0755"
  loop:
    - "{{ dotfiles_dir }}/zsh/zshrc.d"
    - "{{ dotfiles_dir }}/zsh/omz-custom/plugins"
    - "{{ dotfiles_dir }}/zsh/omz-custom/themes"
  tags: config

- name: Stat dotfiles zshrc
  ansible.builtin.stat:
    path: "{{ dotfiles_dir }}/zsh/.zshrc"
  register: repo_zshrc_stat
  tags: config

- name: Create initial .zshrc if missing
  ansible.builtin.copy:
    content: |
      # Enable Powerlevel10k instant prompt. Should stay close to the top of ~/.zshrc.
      # Initialization code that may require console input (password prompts, [y/n]
      # confirmations, etc.) must go above this block; everything else may go below.
      if [[ -r "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh" ]]; then
        source "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh"
      fi

      # If you come from bash you might have to change your $PATH.
      # export PATH=$HOME/bin:$HOME/.local/bin:/usr/local/bin:$PATH

      # Path to your Oh My Zsh installation.
      export ZSH="$HOME/.oh-my-zsh"

      # Set name of the theme to load --- if set to "random", it will
      # load a random theme each time Oh My Zsh is loaded, in which case,
      # to know which specific one was loaded, run: echo $RANDOM_THEME
      # See https://github.com/ohmyzsh/ohmyzsh/wiki/Themes
      ZSH_THEME="powerlevel10k/powerlevel10k"

      # Set list of themes to pick from when loading at random
      # Setting this variable when ZSH_THEME=random will cause zsh to load
      # a theme from this variable instead of looking in $ZSH/themes/
      # If set to an empty array, this variable will have no effect.
      # ZSH_THEME_RANDOM_CANDIDATES=( "robbyrussell" "agnoster" )

      # Uncomment the following line to use case-sensitive completion.
      # CASE_SENSITIVE="true"

      # Uncomment the following line to use hyphen-insensitive completion.
      # Case-sensitive completion must be off. _ and - will be interchangeable.
      # HYPHEN_INSENSITIVE="true"

      # Uncomment one of the following lines to change the auto-update behavior
      # zstyle ':omz:update' mode disabled  # disable automatic updates
      # zstyle ':omz:update' mode auto      # update automatically without asking
      # zstyle ':omz:update' mode reminder  # just remind me to update when it's time

      # Uncomment the following line to change how often to auto-update (in days).
      # zstyle ':omz:update' frequency 13

      # Uncomment the following line if pasting URLs and other text is messed up.
      # DISABLE_MAGIC_FUNCTIONS="true"

      # Uncomment the following line to disable colors in ls.
      # DISABLE_LS_COLORS="true"

      # Uncomment the following line to disable auto-setting terminal title.
      # DISABLE_AUTO_TITLE="true"

      # Uncomment the following line to enable command auto-correction.
      # ENABLE_CORRECTION="true"

      # Uncomment the following line to display red dots whilst waiting for completion.
      # You can also set it to another string to have that shown instead of the default red dots.
      # e.g. COMPLETION_WAITING_DOTS="%F{yellow}waiting...%f"
      # Caution: this setting can cause issues with multiline prompts in zsh < 5.7.1 (see #5765)
      # COMPLETION_WAITING_DOTS="true"

      # Uncomment the following line if you want to disable marking untracked files
      # under VCS as dirty. This makes repository status check for large repositories
      # much, much faster.
      # DISABLE_UNTRACKED_FILES_DIRTY="true"

      # Uncomment the following line if you want to change the command execution time
      # stamp shown in the history command output.
      # You can set one of the optional three formats:
      # "mm/dd/yyyy"|"dd.mm.yyyy"|"yyyy-mm-dd"
      # or set a custom format using the strftime function format specifications,
      # see 'man strftime' for details.
      # HIST_STAMPS="mm/dd/yyyy"

      # Would you like to use another custom folder than $ZSH/custom?
      # ZSH_CUSTOM=/path/to/new-custom-folder

      # Which plugins would you like to load?
      # Standard plugins can be found in $ZSH/plugins/
      # Custom plugins may be added to $ZSH_CUSTOM/plugins/
      # Example format: plugins=(rails git textmate ruby lighthouse)
      # Add wisely, as too many plugins slow down shell startup.
      plugins=(
      	git
      	zsh-autosuggestions
      	zsh-syntax-highlighting 
      	F-Sy-H #fast syntax highlighting
        aws
      #	zsh-autocomplete
      )

      source $ZSH/oh-my-zsh.sh

      # User configuration

      # export MANPATH="/usr/local/man:$MANPATH"

      # You may need to manually set your language environment
      # export LANG=en_US.UTF-8

      # Preferred editor for local and remote sessions
      # if [[ -n $SSH_CONNECTION ]]; then
      #   export EDITOR='vim'
      # else
      #   export EDITOR='nvim'
      # fi

      # Compilation flags
      # export ARCHFLAGS="-arch $(uname -m)"

      # Set personal aliases, overriding those provided by Oh My Zsh libs,
      # plugins, and themes. Aliases can be placed here, though Oh My Zsh
      # users are encouraged to define aliases within a top-level file in
      # the $ZSH_CUSTOM folder, with .zsh extension. Examples:
      # - $ZSH_CUSTOM/aliases.zsh
      # - $ZSH_CUSTOM/macos.zsh
      # For a full list of active aliases, run `alias`.
      #
      # Example aliases
      # alias zshconfig="mate ~/.zshrc"
      # alias ohmyzsh="mate ~/.oh-my-zsh"
      alias docker-compose="docker compose"
      #alias phpunit-docker='docker compose exec app vendor/bin/phpunit $@ 2>&1 | sed "s|/var/www/html/|$PWD/|g"'

      phpunit-docker() {
          docker compose exec app vendor/bin/phpunit "$@" 2>&1 | sed "s|/var/www/html/|$(pwd)/|g"
      }

      # To customize prompt, run `p10k configure` or edit ~/.p10k.zsh.
      [[ ! -f ~/.p10k.zsh ]] || source ~/.p10k.zsh
      export GPG_TTY=$(tty)
      #source /home/jray/code/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh
      bindkey -M menuselect "^[OD"   .backward-char # ΓåÉ
      bindkey -M menuselect "^[OC"    .forward-char # ΓåÆ
      bindkey -M menuselect "^[b"    .backward-word # ΓîÑ + ΓåÉ
      bindkey -M menuselect "^[f"     .forward-word # ΓîÑ + ΓåÆ
      bindkey -M menuselect "^A" .beginning-of-line # Γîÿ + ΓåÉ
      bindkey -M menuselect "^E"       .end-of-line # Γîÿ + ΓåÆ
      export NVM_DIR="$([ -z "${XDG_CONFIG_HOME-}" ] && printf %s "${HOME}/.nvm" || printf %s "${XDG_CONFIG_HOME}/nvm")"
      [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh" # This loads nvm
      export PATH=$PATH:/usr/local/go/bin
      export PATH=$PATH:/snap/bin
      export PATH="$HOME/go/bin:$PATH"
      export PATH="$HOME/.bin:$PATH"
      export PATH="$(composer config -g home)/vendor/bin:$PATH"
      export BROWSER="/mnt/c/Program Files/Google/Chrome/Application/chrome.exe"
      export AWS_PAGER=''
    dest: "{{ dotfiles_dir }}/zsh/.zshrc"
    mode: "0644"
  tags: config

- name: Stat existing .zshrc
  ansible.builtin.stat:
    path: "{{ ansible_env.HOME }}/.zshrc"
    follow: false
  register: zshrc_stat
  tags: config

- name: Stat for migration check
  ansible.builtin.stat:
    path: "{{ ansible_env.HOME }}/.zshrc"
    follow: false
  register: home_zshrc_to_migrate
  tags: config

- name: Backup existing .zshrc to backup directory (if migrating)
  ansible.builtin.copy:
    src: "{{ ansible_env.HOME }}/.zshrc"
    dest: "{{ backup_dir }}/zshrc.{{ ansible_date_time.iso8601_basic_short }}"
    remote_src: true
    mode: preserve
  when: 
    - migrate_existing_dotfiles | default(false) | bool
    - zshrc_stat.stat.exists 
    - not zshrc_stat.stat.islnk
  tags: config

- name: Copy home .zshrc to repo (if migrating and exists)
  ansible.builtin.copy:
    src: "{{ ansible_env.HOME }}/.zshrc"
    dest: "{{ dotfiles_dir }}/zsh/.zshrc"
    remote_src: true
    mode: "0644"
  when:
    - migrate_existing_dotfiles | default(false) | bool
    - zshrc_stat.stat.exists
    - not zshrc_stat.stat.islnk
  tags: config

- name: Remove old .zshrc before copying repo version (if migrating)
  ansible.builtin.file:
    path: "{{ ansible_env.HOME }}/.zshrc"
    state: absent
  when: 
    - migrate_existing_dotfiles | default(false) | bool
    - zshrc_stat.stat.exists 
    - not zshrc_stat.stat.islnk
  tags: config

- name: Check if dotfiles zshrc exists after creation
  ansible.builtin.stat:
    path: "{{ dotfiles_dir }}/zsh/.zshrc"
  register: repo_zshrc_stat_final
  tags: config

- name: Copy .zshrc from repo to home (unless migrating from home)
  ansible.builtin.copy:
    src: "{{ dotfiles_dir }}/zsh/.zshrc"
    dest: "{{ ansible_env.HOME }}/.zshrc"
    remote_src: true
    mode: "0644"
  when: repo_zshrc_stat_final.stat.exists and not (migrate_existing_dotfiles | default(false) | bool and home_zshrc_to_migrate.stat.exists)
  tags: config

# Local overrides - NEVER overwrite if exists
- name: Stat .zshrc.local
  ansible.builtin.stat:
    path: "{{ ansible_env.HOME }}/.zshrc.local"
  register: zshrc_local_stat
  tags: config

- name: Create .zshrc.local from template ONLY if missing
  ansible.builtin.template:
    src: zshrc.local.j2
    dest: "{{ ansible_env.HOME }}/.zshrc.local"
    mode: "0644"
    force: false
  when: not zshrc_local_stat.stat.exists
  tags: config

- name: Document that .zshrc.local is user-owned
  ansible.builtin.debug:
    msg:
      - "~/.zshrc.local exists and is NEVER modified by this playbook"
      - "This file is YOUR domain. Edit it directly for machine-specific config."
  when: zshrc_local_stat.stat.exists
  tags: config

# Additional dotfiles management (git, vim, bash, npm, etc.)
- name: Ensure additional config directories exist
  ansible.builtin.file:
    path: "{{ dotfiles_dir }}/{{ item }}"
    state: directory
    mode: "0755"
  loop:
    - git
    - vim
    - shell
    - npm
  tags: config

- name: Manage additional dotfiles (git, vim, bash, npm)
  ansible.builtin.set_fact:
    managed_dotfiles:
      - { name: ".gitconfig", dir: "git", src_name: ".gitconfig" }
      - { name: ".vimrc", dir: "vim", src_name: ".vimrc" }
      - { name: ".bashrc", dir: "shell", src_name: ".bashrc" }
      - { name: ".npmrc", dir: "npm", src_name: ".npmrc" }
  tags: config

- name: Stat home version of {{ dotfile.name }}
  ansible.builtin.stat:
    path: "{{ ansible_env.HOME }}/{{ dotfile.name }}"
    follow: false
  register: home_dotfile_stat
  loop: "{{ managed_dotfiles }}"
  loop_control:
    loop_var: dotfile
  tags: config

- name: Process each managed dotfile
  ansible.builtin.include_tasks:
    file: dotfile_tasks.yml
  vars:
    dotfile_name: "{{ item.name }}"
    dotfile_dir: "{{ item.dir }}"
    dotfile_src: "{{ item.src_name }}"
  loop: "{{ managed_dotfiles }}"
  tags: config

# Oh My Zsh installation
- name: Check if zsh is available
  ansible.builtin.shell: command -v zsh
  register: zsh_available
  changed_when: false
  failed_when: false
  tags: omz

- name: Stat Oh My Zsh directory
  ansible.builtin.stat:
    path: "{{ ansible_env.HOME }}/.oh-my-zsh"
  register: omz_stat
  tags: omz

- name: Warn if zsh not available for OMZ
  ansible.builtin.debug:
    msg: "WARNING: Zsh not found. Skipping Oh My Zsh installation. Install zsh first."
  when: zsh_available.rc != 0
  tags: omz

- name: Install Oh My Zsh when missing
  block:
    - name: Create temporary file for installer
      ansible.builtin.tempfile:
        state: file
      register: omz_tmp
      check_mode: false

    - name: Download Oh My Zsh installer
      ansible.builtin.get_url:
        url: https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh
        dest: "{{ omz_tmp.path }}"
        mode: "0700"
      check_mode: false

    - name: Run Oh My Zsh installer non-interactively
      ansible.builtin.command: >-
        env RUNZSH=no CHSH=no KEEP_ZSHRC=yes sh {{ omz_tmp.path }}
      args:
        creates: "{{ ansible_env.HOME }}/.oh-my-zsh"
  when:
    - not omz_stat.stat.exists
    - zsh_available.rc == 0
  always:
    - name: Remove temporary installer file
      ansible.builtin.file:
        path: "{{ omz_tmp.path | default('') }}"
        state: absent
      when: omz_tmp is defined and omz_tmp.path is defined
      check_mode: false
  tags: omz

# Shell change
- name: Determine current shell (Linux)
  ansible.builtin.command: "getent passwd {{ ansible_user_id }}"
  register: passwd_entry_getent
  changed_when: false
  failed_when: false
  when: ansible_system == 'Linux'
  tags: shell

- name: Determine current shell (fallback)
  ansible.builtin.command: "dscl . -read /Users/{{ ansible_user_id }} UserShell"
  register: passwd_entry_dscl
  changed_when: false
  failed_when: false
  when: ansible_system == 'Darwin'
  tags: shell

- name: Set passwd entry fact
  ansible.builtin.set_fact:
    passwd_entry:
      stdout: "{{ passwd_entry_getent.stdout | default(passwd_entry_dscl.stdout | default('')) }}"
  tags: shell

- name: Discover zsh path
  ansible.builtin.shell: command -v zsh
  register: zsh_path
  changed_when: false
  failed_when: false
  tags: shell

- name: Set default shell to zsh
  ansible.builtin.command: "chsh -s {{ zsh_path.stdout }} {{ ansible_user_id }}"
  when:
    - set_default_shell | bool
    - passwd_entry.stdout is not regex('zsh$')
    - zsh_path.rc == 0
    - zsh_path.stdout | length > 0
  register: chsh_result
  changed_when: chsh_result.rc == 0
  failed_when: false
  tags: shell

- name: Warn if default shell change failed
  ansible.builtin.debug:
    msg: "Could not change default shell automatically. Run: chsh -s {{ zsh_path.stdout }}"
  when:
    - set_default_shell | bool
    - chsh_result is defined
    - chsh_result.failed | default(false)
    - zsh_path.stdout | length > 0
  tags: shell

# Bin scripts linking
- name: Ensure ~/.local/bin exists
  ansible.builtin.file:
    path: "{{ ansible_env.HOME }}/.local/bin"
    state: directory
    mode: "0755"
  tags: bin

- name: Link bin scripts to ~/.local/bin
  ansible.builtin.file:
    src: "{{ dotfiles_dir }}/bin/{{ item }}"
    dest: "{{ ansible_env.HOME }}/.local/bin/{{ item }}"
    state: link
    force: true
  loop:
    - dotfiles-check-updates.sh
    - dotfiles-pull-updates.sh
    - dotfiles-link-bin.sh
  when: dotfiles_dir is defined
  tags: bin

- name: Note on bin scripts
  ansible.builtin.debug:
    msg:
      - "Update utilities linked to ~/.local/bin"
      - "Ensure ~/.local/bin is in your PATH (typically automatic)"
  tags: bin
