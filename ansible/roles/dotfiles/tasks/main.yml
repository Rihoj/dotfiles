---
# Package installation
- name: Determine package list
  ansible.builtin.set_fact:
    dotfiles_packages:
      - git
      - curl
      - zsh
      - less
      - vim
      - fonts-powerline
      - fzf
  tags: packages

- name: Check if sudo is available
  ansible.builtin.command: command -v sudo
  register: sudo_check
  changed_when: false
  failed_when: false
  when: install_deps | bool
  tags: packages

- name: Install prerequisites via apt (Debian/Ubuntu)
  ansible.builtin.apt:
    name: "{{ dotfiles_packages }}"
    state: present
    update_cache: true
    cache_valid_time: 3600
  when:
    - install_deps | bool
    - ansible_facts['os_family'] == 'Debian'
  become: true
  register: apt_install_result
  failed_when: false
  tags: packages

- name: Install prerequisites via dnf (Fedora)
  ansible.builtin.dnf:
    name: "{{ dotfiles_packages }}"
    state: present
  when:
    - install_deps | bool
    - ansible_facts['os_family'] == 'RedHat'
  become: true
  register: dnf_install_result
  failed_when: false
  tags: packages

- name: Install prerequisites via pacman (Arch)
  community.general.pacman:
    name: "{{ dotfiles_packages }}"
    state: present
  when:
    - install_deps | bool
    - ansible_facts['os_family'] == 'Archlinux'
  become: true
  register: pacman_install_result
  failed_when: false
  tags: packages

- name: Set package install result
  ansible.builtin.set_fact:
    pkg_install_result: "{{ apt_install_result | default(dnf_install_result) | default(pacman_install_result) | default({}) }}"
  when: install_deps | bool
  tags: packages

- name: Warn if package installation failed
  ansible.builtin.debug:
    msg: "WARNING: Package installation failed or was skipped. Required tools (git, curl, zsh) may be missing."
  when:
    - install_deps | bool
    - pkg_install_result is defined
    - pkg_install_result.failed | default(false)
  tags: packages

- name: Verify critical packages are installed
  ansible.builtin.shell: "command -v {{ item }}"
  register: critical_pkg_check
  changed_when: false
  failed_when: false
  loop:
    - git
    - zsh
  tags: packages

- name: Fail if critical packages are missing
  ansible.builtin.fail:
    msg: "CRITICAL: {{ item.item }} is not installed. Please install it manually: sudo apt-get install {{ item.item }}"
  when:
    - install_deps | bool
    - item.rc != 0
  loop: "{{ critical_pkg_check.results }}"
  tags: packages

# Font installation for Powerlevel10k
- name: Install powerline-fonts via dnf (Fedora)
  ansible.builtin.dnf:
    name: powerline-fonts
    state: present
  when:
    - install_deps | bool
    - ansible_facts['os_family'] == 'RedHat'
  become: true
  register: dnf_font_result
  failed_when: false
  tags: fonts

- name: Install powerline-fonts via pacman (Arch)
  community.general.pacman:
    name: powerline-fonts
    state: present
  when:
    - install_deps | bool
    - ansible_facts['os_family'] == 'Archlinux'
  become: true
  register: pacman_font_result
  failed_when: false
  tags: fonts

- name: Define Nerd Font download targets
  ansible.builtin.set_fact:
    nerd_font_dir: "{{ ansible_facts.env.HOME }}/.local/share/fonts/MesloLGS-NF"
    nerd_font_files:
      - name: "MesloLGS NF Regular.ttf"
        url: "https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS%20NF%20Regular.ttf"
      - name: "MesloLGS NF Bold.ttf"
        url: "https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS%20NF%20Bold.ttf"
      - name: "MesloLGS NF Italic.ttf"
        url: "https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS%20NF%20Italic.ttf"
      - name: "MesloLGS NF Bold Italic.ttf"
        url: "https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS%20NF%20Bold%20Italic.ttf"
  when: install_deps | bool
  tags: fonts

- name: Ensure Nerd Font directory exists
  ansible.builtin.file:
    path: "{{ nerd_font_dir }}"
    state: directory
    mode: "0755"
  when: install_deps | bool
  tags: fonts

- name: Check which Nerd Fonts already exist
  ansible.builtin.stat:
    path: "{{ nerd_font_dir }}/{{ item.name }}"
  loop: "{{ nerd_font_files }}"
  register: existing_fonts
  when: install_deps | bool
  tags: fonts

- name: Download Meslo Nerd Font (per-user)
  ansible.builtin.get_url:
    url: "{{ item.url }}"
    dest: "{{ nerd_font_dir }}/{{ item.name }}"
    mode: "0644"
  loop: "{{ nerd_font_files }}"
  loop_control:
    index_var: font_index
  register: nerd_font_downloads
  when:
    - install_deps | bool
    - not existing_fonts.results[font_index].stat.exists
  tags: fonts

- name: Refresh font cache when Nerd Fonts change
  ansible.builtin.command: fc-cache -f "{{ nerd_font_dir }}"
  changed_when: true
  when:
    - install_deps | bool
    - nerd_font_downloads is defined
    - nerd_font_downloads.results | selectattr('changed', 'equalto', true) | list | length > 0
  tags: fonts

- name: Notify about Powerlevel10k font requirements
  ansible.builtin.debug:
    msg: |
      Powerlevel10k requires a Powerline or Nerd Font for proper rendering.
      
      Installed fonts-powerline package via package manager.
      
      After installation, configure your terminal to use one of these fonts:
      - Recommended: A Nerd Font (https://www.nerdfonts.com/)
      - Alternative: Powerline fonts (already installed)
      
      Popular Nerd Font choices: JetBrains Mono Nerd Font, FiraCode Nerd Font, Meslo Nerd Font
  when: install_deps | bool
  tags: fonts

# Repository setup
- name: Ensure dotfiles directory exists
  ansible.builtin.file:
    path: "{{ dotfiles_dir }}"
    state: directory
    mode: "0755"
  tags: repo

- name: Clone or update dotfiles repo when repo is provided
  ansible.builtin.git:
    repo: "{{ dotfiles_repo }}"
    dest: "{{ dotfiles_dir }}"
    version: HEAD
    update: true
  when: dotfiles_repo | length > 0
  tags: repo

- name: Warn if repo URL not provided
  ansible.builtin.debug:
    msg: "dotfiles_repo not set; expecting existing files in {{ dotfiles_dir }}"
  when: dotfiles_repo | length == 0
  tags: repo

- name: Detect if running from outside dotfiles directory
  ansible.builtin.stat:
    path: "{{ playbook_dir }}/../zsh/zshrc.d"
  register: source_zshrc_d
  when: dotfiles_repo | length == 0
  tags: repo

- name: Check if target zshrc.d directory exists
  ansible.builtin.stat:
    path: "{{ dotfiles_dir }}/zsh/zshrc.d"
  register: target_zshrc_d
  when:
    - dotfiles_repo | length == 0
    - source_zshrc_d.stat.exists | default(false)
  tags: repo

- name: Check if dotfiles directory needs population
  ansible.builtin.find:
    paths: "{{ dotfiles_dir }}/zsh/zshrc.d"
    file_type: file
    patterns: "*.zsh"
  register: existing_zshrc_d_files
  when:
    - dotfiles_repo | length == 0
    - source_zshrc_d.stat.exists | default(false)
    - target_zshrc_d.stat.exists | default(false)
  tags: repo

- name: Check which dotfiles directories exist in source
  ansible.builtin.stat:
    path: "{{ playbook_dir }}/../{{ item }}"
  loop:
    - zsh
    - git
    - vim
    - shell
    - npm
    - bin
  register: source_dotfiles_dirs
  when:
    - dotfiles_repo | length == 0
    - source_zshrc_d.stat.exists | default(false)
    - existing_zshrc_d_files.matched | default(0) == 0
  tags: repo

- name: Copy dotfiles content to dotfiles directory
  ansible.builtin.copy:
    src: "{{ playbook_dir }}/../{{ dir_item.item }}/"
    dest: "{{ dotfiles_dir }}/{{ dir_item.item }}/"
    mode: preserve
    remote_src: true
  loop: "{{ source_dotfiles_dirs.results | default([]) }}"
  loop_control:
    loop_var: dir_item
  when:
    - dotfiles_repo | length == 0
    - source_zshrc_d.stat.exists | default(false)
    - existing_zshrc_d_files.matched | default(0) == 0
    - dir_item.stat.exists | default(false)
  tags: repo

# Zshrc linking with backups
- name: Ensure zsh directories exist
  ansible.builtin.file:
    path: "{{ item }}"
    state: directory
    mode: "0755"
  loop:
    - "{{ dotfiles_dir }}/zsh/zshrc.d"
    - "{{ dotfiles_dir }}/zsh/omz-custom/plugins"
    - "{{ dotfiles_dir }}/zsh/omz-custom/themes"
  tags: config

- name: Stat dotfiles zshrc
  ansible.builtin.stat:
    path: "{{ dotfiles_dir }}/zsh/.zshrc"
  register: repo_zshrc_stat
  tags: config

- name: Create initial .zshrc if missing
  ansible.builtin.copy:
    content: |
      # Enable Powerlevel10k instant prompt. Should stay close to the top of ~/.zshrc.
      # Initialization code that may require console input (password prompts, [y/n]
      # confirmations, etc.) must go above this block; everything else may go below.
      if [[ -r "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh" ]]; then
        source "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh"
      fi

      # Load modular configuration files
      for f in "$HOME/.dotfiles/zsh/zshrc.d"/*.zsh(N); do
        [[ -r "$f" ]] && source "$f"
      done

      # Local per-machine overrides (not committed)
      [[ -f "$HOME/.zshrc.local" ]] && source "$HOME/.zshrc.local"
    dest: "{{ dotfiles_dir }}/zsh/.zshrc"
    mode: "0644"
  tags: config

- name: Stat existing .zshrc
  ansible.builtin.stat:
    path: "{{ ansible_facts.env.HOME }}/.zshrc"
    follow: false
  register: zshrc_stat
  tags: config

- name: Stat for migration check
  ansible.builtin.stat:
    path: "{{ ansible_facts.env.HOME }}/.zshrc"
    follow: false
  register: home_zshrc_to_migrate
  tags: config

- name: Backup existing .zshrc to backup directory (if migrating)
  ansible.builtin.copy:
    src: "{{ ansible_facts.env.HOME }}/.zshrc"
    dest: "{{ backup_dir }}/zshrc.{{ ansible_facts.date_time.iso8601_basic_short }}"
    remote_src: true
    mode: preserve
  when: 
    - migrate_existing_dotfiles | default(false) | bool
    - zshrc_stat.stat.exists 
    - not zshrc_stat.stat.islnk
  tags: config

- name: Copy home .zshrc to repo (if migrating and exists)
  ansible.builtin.copy:
    src: "{{ ansible_facts.env.HOME }}/.zshrc"
    dest: "{{ dotfiles_dir }}/zsh/.zshrc"
    remote_src: true
    mode: "0644"
  when:
    - migrate_existing_dotfiles | default(false) | bool
    - zshrc_stat.stat.exists
    - not zshrc_stat.stat.islnk
  tags: config

- name: Remove old .zshrc before copying repo version (if migrating)
  ansible.builtin.file:
    path: "{{ ansible_facts.env.HOME }}/.zshrc"
    state: absent
  when: 
    - migrate_existing_dotfiles | default(false) | bool
    - zshrc_stat.stat.exists 
    - not zshrc_stat.stat.islnk
  tags: config

- name: Check if dotfiles zshrc exists after creation
  ansible.builtin.stat:
    path: "{{ dotfiles_dir }}/zsh/.zshrc"
  register: repo_zshrc_stat_final
  tags: config

- name: Copy .zshrc from repo to home (unless migrating from home)
  ansible.builtin.copy:
    src: "{{ dotfiles_dir }}/zsh/.zshrc"
    dest: "{{ ansible_facts.env.HOME }}/.zshrc"
    remote_src: true
    mode: "0644"
  when: repo_zshrc_stat_final.stat.exists and not (migrate_existing_dotfiles | default(false) | bool and home_zshrc_to_migrate.stat.exists)
  tags: config

# Local overrides - NEVER overwrite if exists
- name: Stat .zshrc.local
  ansible.builtin.stat:
    path: "{{ ansible_facts.env.HOME }}/.zshrc.local"
  register: zshrc_local_stat
  tags: config

- name: Create .zshrc.local from template ONLY if missing
  ansible.builtin.template:
    src: zshrc.local.j2
    dest: "{{ ansible_facts.env.HOME }}/.zshrc.local"
    mode: "0644"
    force: false
  when: not zshrc_local_stat.stat.exists
  tags: config

- name: Document that .zshrc.local is user-owned
  ansible.builtin.debug:
    msg:
      - "~/.zshrc.local exists and is NEVER modified by this playbook"
      - "This file is YOUR domain. Edit it directly for machine-specific config."
  when: zshrc_local_stat.stat.exists
  tags: config

# Additional dotfiles management (git, vim, bash, npm, etc.)
- name: Ensure additional config directories exist
  ansible.builtin.file:
    path: "{{ dotfiles_dir }}/{{ item }}"
    state: directory
    mode: "0755"
  loop:
    - git
    - vim
    - shell
    - npm
  tags: config

- name: Manage additional dotfiles (git, vim, bash, npm)
  ansible.builtin.set_fact:
    managed_dotfiles:
      - { name: ".gitconfig", dir: "git", src_name: ".gitconfig" }
      - { name: ".vimrc", dir: "vim", src_name: ".vimrc" }
      - { name: ".bashrc", dir: "shell", src_name: ".bashrc" }
      - { name: ".npmrc", dir: "npm", src_name: ".npmrc" }
  tags: config

- name: Stat home version of {{ dotfile.name }}
  ansible.builtin.stat:
    path: "{{ ansible_facts.env.HOME }}/{{ dotfile.name }}"
    follow: false
  register: home_dotfile_stat
  loop: "{{ managed_dotfiles }}"
  loop_control:
    loop_var: dotfile
  tags: config

- name: Process each managed dotfile
  ansible.builtin.include_tasks:
    file: dotfile_tasks.yml
  vars:
    dotfile_name: "{{ item.name }}"
    dotfile_dir: "{{ item.dir }}"
    dotfile_src: "{{ item.src_name }}"
  loop: "{{ managed_dotfiles }}"
  tags: config

# Git local configuration (.gitconfig.local)
- name: Stat .gitconfig.local
  ansible.builtin.stat:
    path: "{{ ansible_facts.env.HOME }}/.gitconfig.local"
  register: gitconfig_local_stat
  tags: config

- name: Create .gitconfig.local from bootstrap input
  ansible.builtin.copy:
    content: |
      # ~/.gitconfig.local
      # Machine-specific git configuration. This file stays out of version control.
      # Created during bootstrap

      [user]
      	name = {{ git_user_name | quote }}
      	email = {{ git_user_email | quote }}
      {% if git_signing_key is defined and git_signing_key %}
      	signingkey = {{ git_signing_key | quote }}
      {% endif %}
    dest: "{{ ansible_facts.env.HOME }}/.gitconfig.local"
    mode: "0644"
  when:
    - not gitconfig_local_stat.stat.exists
    - git_user_name is defined
    - git_user_email is defined
  tags: config

- name: Notify about git user configuration
  ansible.builtin.debug:
    msg:
      - "Git user configuration (.gitconfig.local) not found"
      - "Run: {{ dotfiles_dir }}/bin/setup-git-config.sh to configure your git identity"
      - "This will prompt for your name, email, and GPG key for commit signing"
  when:
    - not gitconfig_local_stat.stat.exists
    - (git_user_name is not defined or git_user_email is not defined)
  tags: config

- name: Document that .gitconfig.local is user-owned
  ansible.builtin.debug:
    msg:
      - "~/.gitconfig.local exists and is NEVER modified by this playbook"
      - "This file contains your git identity (name, email, GPG key)"
      - "To reconfigure, run: {{ dotfiles_dir }}/bin/setup-git-config.sh"
  when: gitconfig_local_stat.stat.exists
  tags: config

# Oh My Zsh installation
- name: Check if zsh is available
  ansible.builtin.shell: command -v zsh
  register: zsh_available
  changed_when: false
  failed_when: false
  tags: omz

- name: Stat Oh My Zsh directory
  ansible.builtin.stat:
    path: "{{ ansible_facts.env.HOME }}/.oh-my-zsh"
  register: omz_stat
  tags: omz

- name: Warn if zsh not available for OMZ
  ansible.builtin.debug:
    msg: "WARNING: Zsh not found. Skipping Oh My Zsh installation. Install zsh first."
  when: zsh_available.rc != 0
  tags: omz

- name: Install Oh My Zsh when missing
  block:
    - name: Create temporary file for installer
      ansible.builtin.tempfile:
        state: file
      register: omz_tmp
      check_mode: false

    - name: Download Oh My Zsh installer
      ansible.builtin.get_url:
        url: https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh
        dest: "{{ omz_tmp.path }}"
        mode: "0700"
      check_mode: false

    - name: Run Oh My Zsh installer non-interactively
      ansible.builtin.command: >-
        env RUNZSH=no CHSH=no KEEP_ZSHRC=yes sh {{ omz_tmp.path }}
      args:
        creates: "{{ ansible_facts.env.HOME }}/.oh-my-zsh"
  when:
    - not omz_stat.stat.exists
    - zsh_available.rc == 0
  always:
    - name: Remove temporary installer file
      ansible.builtin.file:
        path: "{{ omz_tmp.path | default('') }}"
        state: absent
      when: omz_tmp is defined and omz_tmp.path is defined
      check_mode: false
  tags: omz

# Install OMZ plugins and theme
- name: Install zsh-autosuggestions plugin
  ansible.builtin.git:
    repo: https://github.com/zsh-users/zsh-autosuggestions.git
    dest: "{{ ansible_facts.env.HOME }}/.oh-my-zsh/plugins/zsh-autosuggestions"
    version: master
  when: zsh_available.rc == 0
  tags: omz

- name: Install zsh-syntax-highlighting plugin
  ansible.builtin.git:
    repo: https://github.com/zsh-users/zsh-syntax-highlighting.git
    dest: "{{ ansible_facts.env.HOME }}/.oh-my-zsh/plugins/zsh-syntax-highlighting"
    version: master
  when: zsh_available.rc == 0
  tags: omz

- name: Install F-Sy-H (fast-syntax-highlighting) plugin
  ansible.builtin.git:
    repo: https://github.com/zdharma-continuum/fast-syntax-highlighting.git
    dest: "{{ ansible_facts.env.HOME }}/.oh-my-zsh/plugins/F-Sy-H"
    version: master
  when: zsh_available.rc == 0
  tags: omz

- name: Install powerlevel10k theme
  ansible.builtin.git:
    repo: https://github.com/romkatv/powerlevel10k.git
    dest: "{{ ansible_facts.env.HOME }}/.oh-my-zsh/themes/powerlevel10k"
    version: master
  when: zsh_available.rc == 0
  tags: omz

# Shell change
- name: Determine current shell (Linux)
  ansible.builtin.command: "getent passwd {{ ansible_facts.user_id }}"
  register: passwd_entry_getent
  changed_when: false
  failed_when: false
  when: ansible_facts.system == 'Linux'
  tags: shell

- name: Determine current shell (fallback)
  ansible.builtin.command: "dscl . -read /Users/{{ ansible_facts.user_id }} UserShell"
  register: passwd_entry_dscl
  changed_when: false
  failed_when: false
  when: ansible_facts.system == 'Darwin'
  tags: shell

- name: Set passwd entry fact
  ansible.builtin.set_fact:
    passwd_entry:
      stdout: "{{ passwd_entry_getent.stdout | default(passwd_entry_dscl.stdout | default('')) }}"
  tags: shell

- name: Discover zsh path
  ansible.builtin.shell: command -v zsh
  register: zsh_path
  changed_when: false
  failed_when: false
  tags: shell

- name: Set default shell to zsh (using ansible.builtin.user)
  ansible.builtin.user:
    name: "{{ ansible_facts.user_id }}"
    shell: "{{ zsh_path.stdout }}"
  register: user_shell_change
  become: true
  when:
    - set_default_shell | bool
    - passwd_entry.stdout is not regex('zsh$')
    - zsh_path.rc == 0
    - zsh_path.stdout | length > 0
  tags: shell

- name: Verify shell change
  ansible.builtin.command: "getent passwd {{ ansible_facts.user_id }}"
  register: passwd_entry_verify
  changed_when: false
  failed_when: false
  when:
    - set_default_shell | bool
    - ansible_facts.system == 'Linux'
  tags: shell

- name: Report shell status
  ansible.builtin.debug:
    msg: |
      Default shell configuration:
      {% if passwd_entry_verify.stdout is regex('zsh$') %}
      ✓ Shell successfully set to zsh
      {% else %}
      ⚠ Shell is still: {{ passwd_entry_verify.stdout.split(':')[-1] | default('unknown') }}
      Run: chsh -s {{ zsh_path.stdout }}
      {% endif %}
  when:
    - set_default_shell | bool
    - passwd_entry_verify is defined
  tags: shell

- name: Warn if default shell change failed
  ansible.builtin.debug:
    msg: "Could not change default shell automatically. Run: chsh -s {{ zsh_path.stdout }}"
  when:
    - set_default_shell | bool
    - chsh_result is defined
    - chsh_result.failed | default(false)
    - zsh_path.stdout | length > 0
  tags: shell

# Bin scripts linking
- name: Ensure ~/.local/bin exists
  ansible.builtin.file:
    path: "{{ ansible_facts.env.HOME }}/.local/bin"
    state: directory
    mode: "0755"
  tags: bin

- name: Link bin scripts to ~/.local/bin
  ansible.builtin.file:
    src: "{{ dotfiles_dir }}/bin/{{ item }}"
    dest: "{{ ansible_facts.env.HOME }}/.local/bin/{{ item }}"
    state: link
    force: true
  loop:
    - dotfiles-check-updates.sh
    - dotfiles-pull-updates.sh
    - dotfiles-link-bin.sh
    - setup-git-config.sh
  when: dotfiles_dir is defined
  tags: bin

- name: Note on bin scripts
  ansible.builtin.debug:
    msg:
      - "Update utilities linked to ~/.local/bin"
      - "Ensure ~/.local/bin is in your PATH (typically automatic)"
  tags: bin
